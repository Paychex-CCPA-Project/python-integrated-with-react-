{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { FETCH_END } from '../../../actions/fetchActions';\nimport { CREATE, DELETE, DELETE_MANY, GET_LIST, GET_MANY, GET_MANY_REFERENCE, GET_ONE, UPDATE, UPDATE_MANY } from '../../../dataFetchActions';\nimport getFetchedAt from '../../../util/getFetchedAt';\n/**\n * Make the fetchedAt property non enumerable\n */\n\nexport var hideFetchedAt = function hideFetchedAt(records) {\n  Object.defineProperty(records, 'fetchedAt', {\n    enumerable: false,\n    configurable: false,\n    writable: false\n  });\n  return records;\n};\n/**\n * Add new records to the pool, and remove outdated ones.\n *\n * This is the equivalent of a stale-while-revalidate caching strategy:\n * The cached data is displayed before fetching, and stale data is removed\n * only once fresh data is fetched.\n */\n\nexport var addRecords = function addRecords(newRecords, oldRecords) {\n  if (newRecords === void 0) {\n    newRecords = [];\n  }\n\n  var newRecordsById = {};\n  newRecords.forEach(function (record) {\n    return newRecordsById[record.id] = record;\n  });\n  var newFetchedAt = getFetchedAt(newRecords.map(function (_a) {\n    var id = _a.id;\n    return id;\n  }), oldRecords.fetchedAt);\n  var records = {\n    fetchedAt: newFetchedAt\n  };\n  Object.keys(newFetchedAt).forEach(function (id) {\n    return records[id] = newRecordsById[id] || oldRecords[id];\n  });\n  return hideFetchedAt(records);\n};\n/**\n * Remove records from the pool\n */\n\nvar removeRecords = function removeRecords(removedRecordIds, oldRecords) {\n  if (removedRecordIds === void 0) {\n    removedRecordIds = [];\n  }\n\n  var records = Object.entries(oldRecords).filter(function (_a) {\n    var key = _a[0];\n    return !removedRecordIds.includes(key);\n  }).reduce(function (obj, _a) {\n    var key = _a[0],\n        val = _a[1];\n\n    var _b;\n\n    return __assign({}, obj, (_b = {}, _b[key] = val, _b));\n  }, {\n    fetchedAt: {}\n  });\n  records.fetchedAt = Object.entries(oldRecords.fetchedAt).filter(function (_a) {\n    var key = _a[0];\n    return !removedRecordIds.includes(key);\n  }).reduce(function (obj, _a) {\n    var key = _a[0],\n        val = _a[1];\n\n    var _b;\n\n    return __assign({}, obj, (_b = {}, _b[key] = val, _b));\n  }, {});\n  return hideFetchedAt(records);\n};\n\nvar initialState = hideFetchedAt({\n  fetchedAt: {}\n});\n\nvar dataReducer = function dataReducer(previousState, _a) {\n  if (previousState === void 0) {\n    previousState = initialState;\n  }\n\n  var payload = _a.payload,\n      meta = _a.meta;\n\n  if (meta && meta.optimistic) {\n    if (meta.fetch === UPDATE) {\n      var updatedRecord = __assign({}, previousState[payload.id], payload.data);\n\n      return addRecords([updatedRecord], previousState);\n    }\n\n    if (meta.fetch === UPDATE_MANY) {\n      var updatedRecords = payload.ids.map(function (id) {\n        return __assign({}, previousState[id], payload.data);\n      });\n      return addRecords(updatedRecords, previousState);\n    }\n\n    if (meta.fetch === DELETE) {\n      return removeRecords([payload.id], previousState);\n    }\n\n    if (meta.fetch === DELETE_MANY) {\n      return removeRecords(payload.ids, previousState);\n    }\n  }\n\n  if (!meta || !meta.fetchResponse || meta.fetchStatus !== FETCH_END) {\n    return previousState;\n  }\n\n  switch (meta.fetchResponse) {\n    case GET_LIST:\n    case GET_MANY:\n    case GET_MANY_REFERENCE:\n      return addRecords(payload.data, previousState);\n\n    case GET_ONE:\n    case UPDATE:\n    case CREATE:\n      return addRecords([payload.data], previousState);\n\n    default:\n      return previousState;\n  }\n};\n\nexport var getRecord = function getRecord(state, id) {\n  return state[id];\n};\nexport default dataReducer;","map":{"version":3,"sources":["/Users/masonkirby/Desktop/backed/backend/dashboard/node_modules/ra-data-drf/node_modules/ra-core/esm/reducer/admin/resource/data.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","FETCH_END","CREATE","DELETE","DELETE_MANY","GET_LIST","GET_MANY","GET_MANY_REFERENCE","GET_ONE","UPDATE","UPDATE_MANY","getFetchedAt","hideFetchedAt","records","defineProperty","enumerable","configurable","writable","addRecords","newRecords","oldRecords","newRecordsById","forEach","record","id","newFetchedAt","map","_a","fetchedAt","keys","removeRecords","removedRecordIds","entries","filter","key","includes","reduce","obj","val","_b","initialState","dataReducer","previousState","payload","meta","optimistic","fetch","updatedRecord","data","updatedRecords","ids","fetchResponse","fetchStatus","getRecord","state"],"mappings":"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","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { FETCH_END } from '../../../actions/fetchActions';\nimport { CREATE, DELETE, DELETE_MANY, GET_LIST, GET_MANY, GET_MANY_REFERENCE, GET_ONE, UPDATE, UPDATE_MANY, } from '../../../dataFetchActions';\nimport getFetchedAt from '../../../util/getFetchedAt';\n/**\n * Make the fetchedAt property non enumerable\n */\nexport var hideFetchedAt = function (records) {\n    Object.defineProperty(records, 'fetchedAt', {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n    });\n    return records;\n};\n/**\n * Add new records to the pool, and remove outdated ones.\n *\n * This is the equivalent of a stale-while-revalidate caching strategy:\n * The cached data is displayed before fetching, and stale data is removed\n * only once fresh data is fetched.\n */\nexport var addRecords = function (newRecords, oldRecords) {\n    if (newRecords === void 0) { newRecords = []; }\n    var newRecordsById = {};\n    newRecords.forEach(function (record) { return (newRecordsById[record.id] = record); });\n    var newFetchedAt = getFetchedAt(newRecords.map(function (_a) {\n        var id = _a.id;\n        return id;\n    }), oldRecords.fetchedAt);\n    var records = { fetchedAt: newFetchedAt };\n    Object.keys(newFetchedAt).forEach(function (id) { return (records[id] = newRecordsById[id] || oldRecords[id]); });\n    return hideFetchedAt(records);\n};\n/**\n * Remove records from the pool\n */\nvar removeRecords = function (removedRecordIds, oldRecords) {\n    if (removedRecordIds === void 0) { removedRecordIds = []; }\n    var records = Object.entries(oldRecords)\n        .filter(function (_a) {\n        var key = _a[0];\n        return !removedRecordIds.includes(key);\n    })\n        .reduce(function (obj, _a) {\n        var key = _a[0], val = _a[1];\n        var _b;\n        return (__assign({}, obj, (_b = {}, _b[key] = val, _b)));\n    }, {\n        fetchedAt: {},\n    });\n    records.fetchedAt = Object.entries(oldRecords.fetchedAt)\n        .filter(function (_a) {\n        var key = _a[0];\n        return !removedRecordIds.includes(key);\n    })\n        .reduce(function (obj, _a) {\n        var key = _a[0], val = _a[1];\n        var _b;\n        return (__assign({}, obj, (_b = {}, _b[key] = val, _b)));\n    }, {});\n    return hideFetchedAt(records);\n};\nvar initialState = hideFetchedAt({ fetchedAt: {} });\nvar dataReducer = function (previousState, _a) {\n    if (previousState === void 0) { previousState = initialState; }\n    var payload = _a.payload, meta = _a.meta;\n    if (meta && meta.optimistic) {\n        if (meta.fetch === UPDATE) {\n            var updatedRecord = __assign({}, previousState[payload.id], payload.data);\n            return addRecords([updatedRecord], previousState);\n        }\n        if (meta.fetch === UPDATE_MANY) {\n            var updatedRecords = payload.ids.map(function (id) { return (__assign({}, previousState[id], payload.data)); });\n            return addRecords(updatedRecords, previousState);\n        }\n        if (meta.fetch === DELETE) {\n            return removeRecords([payload.id], previousState);\n        }\n        if (meta.fetch === DELETE_MANY) {\n            return removeRecords(payload.ids, previousState);\n        }\n    }\n    if (!meta || !meta.fetchResponse || meta.fetchStatus !== FETCH_END) {\n        return previousState;\n    }\n    switch (meta.fetchResponse) {\n        case GET_LIST:\n        case GET_MANY:\n        case GET_MANY_REFERENCE:\n            return addRecords(payload.data, previousState);\n        case GET_ONE:\n        case UPDATE:\n        case CREATE:\n            return addRecords([payload.data], previousState);\n        default:\n            return previousState;\n    }\n};\nexport var getRecord = function (state, id) { return state[id]; };\nexport default dataReducer;\n"]},"metadata":{},"sourceType":"module"}