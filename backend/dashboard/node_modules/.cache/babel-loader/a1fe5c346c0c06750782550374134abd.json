{"ast":null,"code":"import { is, check, uid as nextSagaId, wrapSagaDispatch, noop, log } from './utils';\nimport proc from './proc';\nvar RUN_SAGA_SIGNATURE = 'runSaga(storeInterface, saga, ...args)';\nvar NON_GENERATOR_ERR = RUN_SAGA_SIGNATURE + ': saga argument must be a Generator function!';\nexport function runSaga(storeInterface, saga) {\n  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var iterator = void 0;\n\n  if (is.iterator(storeInterface)) {\n    if (process.env.NODE_ENV === 'development') {\n      log('warn', 'runSaga(iterator, storeInterface) has been deprecated in favor of ' + RUN_SAGA_SIGNATURE);\n    }\n\n    iterator = storeInterface;\n    storeInterface = saga;\n  } else {\n    check(saga, is.func, NON_GENERATOR_ERR);\n    iterator = saga.apply(undefined, args);\n    check(iterator, is.iterator, NON_GENERATOR_ERR);\n  }\n\n  var _storeInterface = storeInterface,\n      subscribe = _storeInterface.subscribe,\n      dispatch = _storeInterface.dispatch,\n      getState = _storeInterface.getState,\n      context = _storeInterface.context,\n      sagaMonitor = _storeInterface.sagaMonitor,\n      logger = _storeInterface.logger,\n      onError = _storeInterface.onError;\n  var effectId = nextSagaId();\n\n  if (sagaMonitor) {\n    // monitors are expected to have a certain interface, let's fill-in any missing ones\n    sagaMonitor.effectTriggered = sagaMonitor.effectTriggered || noop;\n    sagaMonitor.effectResolved = sagaMonitor.effectResolved || noop;\n    sagaMonitor.effectRejected = sagaMonitor.effectRejected || noop;\n    sagaMonitor.effectCancelled = sagaMonitor.effectCancelled || noop;\n    sagaMonitor.actionDispatched = sagaMonitor.actionDispatched || noop;\n    sagaMonitor.effectTriggered({\n      effectId: effectId,\n      root: true,\n      parentEffectId: 0,\n      effect: {\n        root: true,\n        saga: saga,\n        args: args\n      }\n    });\n  }\n\n  var task = proc(iterator, subscribe, wrapSagaDispatch(dispatch), getState, context, {\n    sagaMonitor: sagaMonitor,\n    logger: logger,\n    onError: onError\n  }, effectId, saga.name);\n\n  if (sagaMonitor) {\n    sagaMonitor.effectResolved(effectId, task);\n  }\n\n  return task;\n}","map":{"version":3,"sources":["/Users/masonkirby/Desktop/backed/backend/dashboard/node_modules/ra-data-drf/node_modules/redux-saga/es/internal/runSaga.js"],"names":["is","check","uid","nextSagaId","wrapSagaDispatch","noop","log","proc","RUN_SAGA_SIGNATURE","NON_GENERATOR_ERR","runSaga","storeInterface","saga","_len","arguments","length","args","Array","_key","iterator","process","env","NODE_ENV","func","apply","undefined","_storeInterface","subscribe","dispatch","getState","context","sagaMonitor","logger","onError","effectId","effectTriggered","effectResolved","effectRejected","effectCancelled","actionDispatched","root","parentEffectId","effect","task","name"],"mappings":"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","sourcesContent":["import { is, check, uid as nextSagaId, wrapSagaDispatch, noop, log } from './utils';\nimport proc from './proc';\n\nvar RUN_SAGA_SIGNATURE = 'runSaga(storeInterface, saga, ...args)';\nvar NON_GENERATOR_ERR = RUN_SAGA_SIGNATURE + ': saga argument must be a Generator function!';\n\nexport function runSaga(storeInterface, saga) {\n  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var iterator = void 0;\n\n  if (is.iterator(storeInterface)) {\n    if (process.env.NODE_ENV === 'development') {\n      log('warn', 'runSaga(iterator, storeInterface) has been deprecated in favor of ' + RUN_SAGA_SIGNATURE);\n    }\n    iterator = storeInterface;\n    storeInterface = saga;\n  } else {\n    check(saga, is.func, NON_GENERATOR_ERR);\n    iterator = saga.apply(undefined, args);\n    check(iterator, is.iterator, NON_GENERATOR_ERR);\n  }\n\n  var _storeInterface = storeInterface,\n      subscribe = _storeInterface.subscribe,\n      dispatch = _storeInterface.dispatch,\n      getState = _storeInterface.getState,\n      context = _storeInterface.context,\n      sagaMonitor = _storeInterface.sagaMonitor,\n      logger = _storeInterface.logger,\n      onError = _storeInterface.onError;\n\n\n  var effectId = nextSagaId();\n\n  if (sagaMonitor) {\n    // monitors are expected to have a certain interface, let's fill-in any missing ones\n    sagaMonitor.effectTriggered = sagaMonitor.effectTriggered || noop;\n    sagaMonitor.effectResolved = sagaMonitor.effectResolved || noop;\n    sagaMonitor.effectRejected = sagaMonitor.effectRejected || noop;\n    sagaMonitor.effectCancelled = sagaMonitor.effectCancelled || noop;\n    sagaMonitor.actionDispatched = sagaMonitor.actionDispatched || noop;\n\n    sagaMonitor.effectTriggered({ effectId: effectId, root: true, parentEffectId: 0, effect: { root: true, saga: saga, args: args } });\n  }\n\n  var task = proc(iterator, subscribe, wrapSagaDispatch(dispatch), getState, context, { sagaMonitor: sagaMonitor, logger: logger, onError: onError }, effectId, saga.name);\n\n  if (sagaMonitor) {\n    sagaMonitor.effectResolved(effectId, task);\n  }\n\n  return task;\n}"]},"metadata":{},"sourceType":"module"}