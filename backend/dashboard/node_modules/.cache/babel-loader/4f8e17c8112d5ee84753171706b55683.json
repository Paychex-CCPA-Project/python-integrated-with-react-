{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { connect } from 'react-redux';\nimport get from 'lodash/get';\nimport { startUndoable } from '../actions/undoActions';\n\nvar mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    dataProvider: function dataProvider(type, resource, payload, meta) {\n      if (meta === void 0) {\n        meta = {};\n      }\n\n      return new Promise(function (resolve, reject) {\n        var onSuccess = get(meta, 'onSuccess', {});\n        var onFailure = get(meta, 'onFailure', {});\n        var action = {\n          type: 'CUSTOM_FETCH',\n          payload: payload,\n          meta: __assign({}, meta, {\n            resource: resource,\n            fetch: type,\n            onSuccess: __assign({}, onSuccess, {\n              callback: function callback(_a) {\n                var response = _a.payload;\n\n                if (onSuccess.callback) {\n                  onSuccess.callback(response);\n                }\n\n                resolve(response);\n              }\n            }),\n            onFailure: __assign({}, get(meta, 'onFailure', {}), {\n              callback: function callback(_a) {\n                var error = _a.error;\n                var sanitizedError = new Error(error.message ? error.message : error);\n\n                if (onFailure.callback) {\n                  onFailure.callback(sanitizedError);\n                }\n\n                reject(sanitizedError);\n              }\n            })\n          })\n        };\n        return meta.undoable ? dispatch(startUndoable(action)) : dispatch(action);\n      });\n    },\n    dispatch: dispatch\n  };\n};\n/**\n * Higher-order component for fetching the dataProvider\n *\n * Injects a dataProvider function prop, which behaves just like\n * the dataProvider function (same signature, returns a Promise), but\n * uses Redux under the hood. The benefit is that react-admin tracks\n * the loading state when using this function, and shows the loader animation\n * while the dataProvider is waiting for a response.\n *\n * In addition to the 3 parameters of the dataProvider function (verb, resource, payload),\n * the injected dataProvider prop accepts a fourth parameter, an object literal\n * which may contain side effects, of make the action optimistic (with undoable: true).\n *\n * As it uses connect() from react-redux, this HOC also injects the dispatch prop,\n * allowing developers to dispatch additional actions upon completion.\n *\n * @example\n *\n * import { withDataProvider, showNotification } from 'react-admin';\n * class PostList extends Component {\n *     state = {\n *         posts: [],\n *     }\n *\n *     componentDidMount() {\n *         const { dataProvider, dispatch } = this.props;\n *         dataProvider('GET_LIST', 'posts', { filter: { status: 'pending' }})\n *            .then(({ data: posts }) => this.setState({ posts }))\n *            .catch(error => dispatch(showNotification(error.message, 'error')))\n *     }\n *\n *     render() {\n *         const { posts } = this.state;\n *         return (\n *            <Fragment>\n *                {posts.map((post, index) => <PostDetail post={post} key={key} />)}\n *            </Fragment>\n *         );\n *     }\n * }\n *\n * PostList.propTypes = {\n *     dataProvider: PropTypes.func.isRequired,\n * };\n *\n * export default withDataProvider(PostList);\n */\n\n\nvar withDataProvider = function withDataProvider(Component) {\n  return connect(null, mapDispatchToProps)(Component);\n};\n\nexport default withDataProvider;","map":{"version":3,"sources":["/Users/masonkirby/Desktop/backed/backend/dashboard/node_modules/ra-data-drf/node_modules/ra-core/esm/util/withDataProvider.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","connect","get","startUndoable","mapDispatchToProps","dispatch","dataProvider","type","resource","payload","meta","Promise","resolve","reject","onSuccess","onFailure","action","fetch","callback","_a","response","error","sanitizedError","Error","message","undoable","withDataProvider","Component"],"mappings":"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","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { connect } from 'react-redux';\nimport get from 'lodash/get';\nimport { startUndoable } from '../actions/undoActions';\nvar mapDispatchToProps = function (dispatch) { return ({\n    dataProvider: function (type, resource, payload, meta) {\n        if (meta === void 0) { meta = {}; }\n        return new Promise(function (resolve, reject) {\n            var onSuccess = get(meta, 'onSuccess', {});\n            var onFailure = get(meta, 'onFailure', {});\n            var action = {\n                type: 'CUSTOM_FETCH',\n                payload: payload,\n                meta: __assign({}, meta, { resource: resource, fetch: type, onSuccess: __assign({}, onSuccess, { callback: function (_a) {\n                            var response = _a.payload;\n                            if (onSuccess.callback) {\n                                onSuccess.callback(response);\n                            }\n                            resolve(response);\n                        } }), onFailure: __assign({}, get(meta, 'onFailure', {}), { callback: function (_a) {\n                            var error = _a.error;\n                            var sanitizedError = new Error(error.message ? error.message : error);\n                            if (onFailure.callback) {\n                                onFailure.callback(sanitizedError);\n                            }\n                            reject(sanitizedError);\n                        } }) }),\n            };\n            return meta.undoable\n                ? dispatch(startUndoable(action))\n                : dispatch(action);\n        });\n    },\n    dispatch: dispatch,\n}); };\n/**\n * Higher-order component for fetching the dataProvider\n *\n * Injects a dataProvider function prop, which behaves just like\n * the dataProvider function (same signature, returns a Promise), but\n * uses Redux under the hood. The benefit is that react-admin tracks\n * the loading state when using this function, and shows the loader animation\n * while the dataProvider is waiting for a response.\n *\n * In addition to the 3 parameters of the dataProvider function (verb, resource, payload),\n * the injected dataProvider prop accepts a fourth parameter, an object literal\n * which may contain side effects, of make the action optimistic (with undoable: true).\n *\n * As it uses connect() from react-redux, this HOC also injects the dispatch prop,\n * allowing developers to dispatch additional actions upon completion.\n *\n * @example\n *\n * import { withDataProvider, showNotification } from 'react-admin';\n * class PostList extends Component {\n *     state = {\n *         posts: [],\n *     }\n *\n *     componentDidMount() {\n *         const { dataProvider, dispatch } = this.props;\n *         dataProvider('GET_LIST', 'posts', { filter: { status: 'pending' }})\n *            .then(({ data: posts }) => this.setState({ posts }))\n *            .catch(error => dispatch(showNotification(error.message, 'error')))\n *     }\n *\n *     render() {\n *         const { posts } = this.state;\n *         return (\n *            <Fragment>\n *                {posts.map((post, index) => <PostDetail post={post} key={key} />)}\n *            </Fragment>\n *         );\n *     }\n * }\n *\n * PostList.propTypes = {\n *     dataProvider: PropTypes.func.isRequired,\n * };\n *\n * export default withDataProvider(PostList);\n */\nvar withDataProvider = function (Component) {\n    return connect(null, mapDispatchToProps)(Component);\n};\nexport default withDataProvider;\n"]},"metadata":{},"sourceType":"module"}