{"ast":null,"code":"import { kTrue, noop } from './utils';\nexport var BUFFER_OVERFLOW = \"Channel's Buffer overflow!\";\nvar ON_OVERFLOW_THROW = 1;\nvar ON_OVERFLOW_DROP = 2;\nvar ON_OVERFLOW_SLIDE = 3;\nvar ON_OVERFLOW_EXPAND = 4;\nvar zeroBuffer = {\n  isEmpty: kTrue,\n  put: noop,\n  take: noop\n};\n\nfunction ringBuffer() {\n  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  var overflowAction = arguments[1];\n  var arr = new Array(limit);\n  var length = 0;\n  var pushIndex = 0;\n  var popIndex = 0;\n\n  var push = function push(it) {\n    arr[pushIndex] = it;\n    pushIndex = (pushIndex + 1) % limit;\n    length++;\n  };\n\n  var take = function take() {\n    if (length != 0) {\n      var it = arr[popIndex];\n      arr[popIndex] = null;\n      length--;\n      popIndex = (popIndex + 1) % limit;\n      return it;\n    }\n  };\n\n  var flush = function flush() {\n    var items = [];\n\n    while (length) {\n      items.push(take());\n    }\n\n    return items;\n  };\n\n  return {\n    isEmpty: function isEmpty() {\n      return length == 0;\n    },\n    put: function put(it) {\n      if (length < limit) {\n        push(it);\n      } else {\n        var doubledLimit = void 0;\n\n        switch (overflowAction) {\n          case ON_OVERFLOW_THROW:\n            throw new Error(BUFFER_OVERFLOW);\n\n          case ON_OVERFLOW_SLIDE:\n            arr[pushIndex] = it;\n            pushIndex = (pushIndex + 1) % limit;\n            popIndex = pushIndex;\n            break;\n\n          case ON_OVERFLOW_EXPAND:\n            doubledLimit = 2 * limit;\n            arr = flush();\n            length = arr.length;\n            pushIndex = arr.length;\n            popIndex = 0;\n            arr.length = doubledLimit;\n            limit = doubledLimit;\n            push(it);\n            break;\n\n          default: // DROP\n\n        }\n      }\n    },\n    take: take,\n    flush: flush\n  };\n}\n\nexport var buffers = {\n  none: function none() {\n    return zeroBuffer;\n  },\n  fixed: function fixed(limit) {\n    return ringBuffer(limit, ON_OVERFLOW_THROW);\n  },\n  dropping: function dropping(limit) {\n    return ringBuffer(limit, ON_OVERFLOW_DROP);\n  },\n  sliding: function sliding(limit) {\n    return ringBuffer(limit, ON_OVERFLOW_SLIDE);\n  },\n  expanding: function expanding(initialSize) {\n    return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);\n  }\n};","map":{"version":3,"sources":["/Users/masonkirby/Desktop/backed/backend/dashboard/node_modules/ra-data-drf/node_modules/redux-saga/es/internal/buffers.js"],"names":["kTrue","noop","BUFFER_OVERFLOW","ON_OVERFLOW_THROW","ON_OVERFLOW_DROP","ON_OVERFLOW_SLIDE","ON_OVERFLOW_EXPAND","zeroBuffer","isEmpty","put","take","ringBuffer","limit","arguments","length","undefined","overflowAction","arr","Array","pushIndex","popIndex","push","it","flush","items","doubledLimit","Error","buffers","none","fixed","dropping","sliding","expanding","initialSize"],"mappings":"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","sourcesContent":["import { kTrue, noop } from './utils';\n\nexport var BUFFER_OVERFLOW = \"Channel's Buffer overflow!\";\n\nvar ON_OVERFLOW_THROW = 1;\nvar ON_OVERFLOW_DROP = 2;\nvar ON_OVERFLOW_SLIDE = 3;\nvar ON_OVERFLOW_EXPAND = 4;\n\nvar zeroBuffer = { isEmpty: kTrue, put: noop, take: noop };\n\nfunction ringBuffer() {\n  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  var overflowAction = arguments[1];\n\n  var arr = new Array(limit);\n  var length = 0;\n  var pushIndex = 0;\n  var popIndex = 0;\n\n  var push = function push(it) {\n    arr[pushIndex] = it;\n    pushIndex = (pushIndex + 1) % limit;\n    length++;\n  };\n\n  var take = function take() {\n    if (length != 0) {\n      var it = arr[popIndex];\n      arr[popIndex] = null;\n      length--;\n      popIndex = (popIndex + 1) % limit;\n      return it;\n    }\n  };\n\n  var flush = function flush() {\n    var items = [];\n    while (length) {\n      items.push(take());\n    }\n    return items;\n  };\n\n  return {\n    isEmpty: function isEmpty() {\n      return length == 0;\n    },\n    put: function put(it) {\n      if (length < limit) {\n        push(it);\n      } else {\n        var doubledLimit = void 0;\n        switch (overflowAction) {\n          case ON_OVERFLOW_THROW:\n            throw new Error(BUFFER_OVERFLOW);\n          case ON_OVERFLOW_SLIDE:\n            arr[pushIndex] = it;\n            pushIndex = (pushIndex + 1) % limit;\n            popIndex = pushIndex;\n            break;\n          case ON_OVERFLOW_EXPAND:\n            doubledLimit = 2 * limit;\n\n            arr = flush();\n\n            length = arr.length;\n            pushIndex = arr.length;\n            popIndex = 0;\n\n            arr.length = doubledLimit;\n            limit = doubledLimit;\n\n            push(it);\n            break;\n          default:\n          // DROP\n        }\n      }\n    },\n    take: take,\n    flush: flush\n  };\n}\n\nexport var buffers = {\n  none: function none() {\n    return zeroBuffer;\n  },\n  fixed: function fixed(limit) {\n    return ringBuffer(limit, ON_OVERFLOW_THROW);\n  },\n  dropping: function dropping(limit) {\n    return ringBuffer(limit, ON_OVERFLOW_DROP);\n  },\n  sliding: function sliding(limit) {\n    return ringBuffer(limit, ON_OVERFLOW_SLIDE);\n  },\n  expanding: function expanding(initialSize) {\n    return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);\n  }\n};"]},"metadata":{},"sourceType":"module"}